// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncGenerator, __asyncValues, __await } from "tslib";
// The eslint plugin mentioned below doesn't follow through the extended types.
/* eslint-disable @azure/azure-sdk/ts-apisurface-supportcancellation */
// This file makes more sense if ordered based on how meaningful are some methods in relation to others.
/* eslint-disable @typescript-eslint/member-ordering */
/// <reference lib="esnext.asynciterable" />
import { isTokenCredential, signingPolicy, createPipelineFromOptions } from "@azure/core-http";
import { logger } from "./log";
import { WellKnownIssuerNames, DefaultCertificatePolicy, LATEST_API_VERSION } from "./certificatesModels";
import { KeyVaultClient } from "./generated/keyVaultClient";
import { SDK_VERSION } from "./constants";
import "@azure/core-paging";
import { challengeBasedAuthenticationPolicy, createTraceFunction } from "../../keyvault-common/src";
import { CreateCertificatePoller } from "./lro/create/poller";
import { CertificateOperationPoller } from "./lro/operation/poller";
import { DeleteCertificatePoller } from "./lro/delete/poller";
import { RecoverDeletedCertificatePoller } from "./lro/recover/poller";
import { parseCertificateBytes } from "./utils";
import { parseKeyVaultCertificateIdentifier } from "./identifier";
import { coreContactsToCertificateContacts, getCertificateFromCertificateBundle, getCertificateOperationFromCoreOperation, getCertificateWithPolicyFromCertificateBundle, getDeletedCertificateFromDeletedCertificateBundle, getDeletedCertificateFromItem, getPropertiesFromCertificateBundle, toCoreAttributes, toCorePolicy, toPublicIssuer, toPublicPolicy } from "./transformations";
export { parseKeyVaultCertificateIdentifier, DefaultCertificatePolicy, WellKnownIssuerNames as WellKnownIssuer, logger };
const withTrace = createTraceFunction("Azure.KeyVault.Certificates.CertificateClient");
/**
 * The client to interact with the KeyVault certificates functionality
 */
export class CertificateClient {
    /**
     * Creates an instance of CertificateClient.
     * @param vaultUrl - the base URL to the vault.
     * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \@azure/identity package to create a credential that suits your needs.
     * @param pipelineOptions - Pipeline options used to configure Key Vault API requests.
     *                          Omit this parameter to use the default pipeline configuration.
     */
    constructor(vaultUrl, credential, pipelineOptions = {}) {
        this.vaultUrl = vaultUrl;
        const libInfo = `azsdk-js-keyvault-certificates/${SDK_VERSION}`;
        if (pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions.userAgentPrefix =
                pipelineOptions.userAgentOptions.userAgentPrefix !== undefined
                    ? `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`
                    : libInfo;
        }
        else {
            pipelineOptions.userAgentOptions = {
                userAgentPrefix: libInfo
            };
        }
        const authPolicy = isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : signingPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), { loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: [
                    "x-ms-keyvault-region",
                    "x-ms-keyvault-network-info",
                    "x-ms-keyvault-service-version"
                ]
            } });
        this.client = new KeyVaultClient(pipelineOptions.serviceVersion || LATEST_API_VERSION, createPipelineFromOptions(internalPipelineOptions, authPolicy));
    }
    listPropertiesOfCertificatesPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfCertificatesPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize, includePending: options.includePending }, options);
                const currentSetResponse = yield __await(withTrace("listPropertiesOfCertificates", optionsComplete, (updatedOptions) => this.client.getCertificates(this.vaultUrl, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(getPropertiesFromCertificateBundle, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(withTrace("listPropertiesOfCertificates", options, (updatedOptions) => this.client.getCertificates(continuationState.continuationToken, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(getPropertiesFromCertificateBundle, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listPropertiesOfCertificatesAll(options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfCertificatesAll_1() {
            var e_1, _a;
            const f = {};
            try {
                for (var _b = __asyncValues(this.listPropertiesOfCertificatesPage(f, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const certificate of page) {
                        yield yield __await(certificate);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Iterates the latest version of all certificates in the vault.  The full certificate identifier and attributes are provided
     * in the response. No values are returned for the certificates. This operations requires the certificates/list permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * // All in one call
     * for await (const certificateProperties of client.listPropertiesOfCertificates()) {
     *   console.log(certificateProperties);
     * }
     * // By pages
     * for await (const page of client.listPropertiesOfCertificates().byPage()) {
     *   for (const certificateProperties of page) {
     *     console.log(certificateProperties);
     *   }
     * }
     * ```
     * List all versions of the specified certificate.
     * @param options - The optional parameters
     */
    listPropertiesOfCertificates(options = {}) {
        const iter = this.listPropertiesOfCertificatesAll(options);
        const result = {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfCertificatesPage(settings, options)
        };
        return result;
    }
    listPropertiesOfCertificateVersionsPage(certificateName, continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfCertificateVersionsPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield __await(withTrace("listPropertiesOfCertificateVersions", optionsComplete, (updatedOptions) => this.client.getCertificateVersions(this.vaultUrl, certificateName, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(getPropertiesFromCertificateBundle, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(withTrace("listPropertiesOfCertificateVersions", options, (updatedOptions) => this.client.getCertificateVersions(continuationState.continuationToken, certificateName, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(getPropertiesFromCertificateBundle, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listPropertiesOfCertificateVersionsAll(certificateName, options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfCertificateVersionsAll_1() {
            var e_2, _a;
            const f = {};
            try {
                for (var _b = __asyncValues(this.listPropertiesOfCertificateVersionsPage(certificateName, f, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield __await(item);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns the versions of a certificate in the specified key
     * vault. This operation requires the certificates/list permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * for await (const certificateProperties of client.listPropertiesOfCertificateVersions("MyCertificate")) {
     *   console.log(certificateProperties.version!);
     * }
     * ```
     * List the versions of a certificate.
     * @param certificateName - The name of the certificate.
     * @param options - The optional parameters
     */
    listPropertiesOfCertificateVersions(certificateName, options = {}) {
        const iter = this.listPropertiesOfCertificateVersionsAll(certificateName, options);
        const result = {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfCertificateVersionsPage(certificateName, settings, options)
        };
        return result;
    }
    /**
     * The DELETE operation applies to any certificate stored in Azure Key Vault. DELETE cannot be applied
     * to an individual version of a certificate.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * This operation requires the certificates/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const createPoller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await createPoller.pollUntilDone();
     *
     * const deletePoller = await client.beginDeleteCertificate("MyCertificate");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginDeleteCertificate("MyCertificate", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedCertificate = await deletePoller.pollUntilDone();
     * console.log(deletedCertificate);
     * ```
     * Deletes a certificate from a specified key vault.
     * @param certificateName - The name of the certificate.
     * @param options - The optional parameters
     */
    async beginDeleteCertificate(certificateName, options = {}) {
        const poller = new DeleteCertificatePoller(Object.assign(Object.assign({ certificateName, client: this.client, vaultUrl: this.vaultUrl }, options), { operationOptions: options }));
        // This will initialize the poller's operation (the deletion of the secret).
        await poller.poll();
        return poller;
    }
    /**
     * Deletes all of the certificate contacts. This operation requires the certificates/managecontacts permission.
     *
     * Example usage:
     * ```ts
     * let client = new CertificateClient(url, credentials);
     * await client.setContacts([{
     *   email: "b@b.com",
     *   name: "b",
     *   phone: "222222222222"
     * }]);
     * await client.deleteContacts();
     * ```
     * Deletes all of the certificate contacts
     * @param options - The optional parameters
     */
    deleteContacts(options = {}) {
        return withTrace("deleteContacts", options, async (updatedOptions) => {
            const result = await this.client.deleteCertificateContacts(this.vaultUrl, updatedOptions);
            return coreContactsToCertificateContacts(result._response.parsedBody);
        });
    }
    /**
     * Sets the certificate contacts for the key vault. This operation requires the certificates/managecontacts permission.
     *
     * Example usage:
     * ```ts
     * let client = new CertificateClient(url, credentials);
     * await client.setContacts([{
     *   email: "b@b.com",
     *   name: "b",
     *   phone: "222222222222"
     * }]);
     * ```
     * Sets the certificate contacts.
     * @param contacts - The contacts to use
     * @param options - The optional parameters
     */
    setContacts(contacts, options = {}) {
        const coreContacts = contacts.map((x) => ({
            emailAddress: x ? x.email : undefined,
            name: x ? x.name : undefined,
            phone: x ? x.phone : undefined
        }));
        return withTrace("setContacts", options, async (updatedOptions) => {
            const result = await this.client.setCertificateContacts(this.vaultUrl, { contactList: coreContacts }, updatedOptions);
            return coreContactsToCertificateContacts(result._response.parsedBody);
        });
    }
    /**
     * Returns the set of certificate contact resources in the specified key vault. This operation requires the certificates/managecontacts permission.
     *
     * Example usage:
     * ```ts
     * let client = new CertificateClient(url, credentials);
     * await client.setContacts([{
     *   email: "b@b.com",
     *   name: "b",
     *   phone: "222222222222"
     * }]);
     * const contacts = await client.getContacts();
     * console.log(contacts);
     * ```
     * Sets the certificate contacts.
     * @param options - The optional parameters
     */
    getContacts(options = {}) {
        return withTrace("getContacts", options, async (updatedOptions) => {
            const result = await this.client.getCertificateContacts(this.vaultUrl, updatedOptions);
            return coreContactsToCertificateContacts(result);
        });
    }
    listPropertiesOfIssuersPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfIssuersPage_1() {
            if (continuationState.continuationToken == null) {
                const requestOptionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield __await(withTrace("listPropertiesOfIssuers", requestOptionsComplete, (updatedOptions) => this.client.getCertificateIssuers(this.vaultUrl, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value);
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(withTrace("listPropertiesOfIssuers", options, (updatedOptions) => this.client.getCertificateIssuers(continuationState.continuationToken, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value);
                }
                else {
                    break;
                }
            }
        });
    }
    listPropertiesOfIssuersAll(options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfIssuersAll_1() {
            var e_3, _a;
            const f = {};
            try {
                for (var _b = __asyncValues(this.listPropertiesOfIssuersPage(f, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield __await(item);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns the set of certificate issuer resources in the specified key vault. This operation requires the certificates/manageissuers/getissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * // All in one call
     * for await (const issuerProperties of client.listPropertiesOfIssuers()) {
     *   console.log(issuerProperties);
     * }
     * // By pages
     * for await (const page of client.listPropertiesOfIssuers().byPage()) {
     *   for (const issuerProperties of page) {
     *     console.log(issuerProperties);
     *   }
     * }
     * ```
     * List the certificate issuers.
     * @param options - The optional parameters
     */
    listPropertiesOfIssuers(options = {}) {
        const iter = this.listPropertiesOfIssuersAll(options);
        const result = {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfIssuersPage(settings, options)
        };
        return result;
    }
    /**
     * The createIssuer operation adds or updates the specified certificate issuer. This
     * operation requires the certificates/setissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * ```
     * Sets the specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param provider - The issuer provider.
     * @param options - The optional parameters
     */
    createIssuer(issuerName, provider, options = {}) {
        return withTrace("createIssuer", options, async (updatedOptions) => {
            const { accountId, password } = updatedOptions;
            const generatedOptions = Object.assign(Object.assign({}, updatedOptions), { credentials: {
                    accountId,
                    password
                } });
            if (updatedOptions.organizationId ||
                (updatedOptions.administratorContacts && updatedOptions.administratorContacts.length)) {
                generatedOptions.organizationDetails = {
                    id: updatedOptions.organizationId,
                    adminDetails: updatedOptions.administratorContacts
                        ? updatedOptions.administratorContacts.map((x) => ({
                            emailAddress: x.email,
                            phone: x.phone,
                            firstName: x.firstName,
                            lastName: x.lastName
                        }))
                        : undefined
                };
            }
            if (updatedOptions.enabled !== undefined) {
                generatedOptions.attributes = {
                    enabled: updatedOptions.enabled
                };
            }
            const result = await this.client.setCertificateIssuer(this.vaultUrl, issuerName, provider, generatedOptions);
            return toPublicIssuer(result._response.parsedBody);
        });
    }
    /**
     * The updateIssuer operation performs an update on the specified certificate issuer
     * entity. This operation requires the certificates/setissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * await client.updateIssuer("IssuerName", {
     *   provider: "Provider2"
     * });
     * ```
     * Updates the specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param options - The optional parameters
     */
    async updateIssuer(issuerName, options = {}) {
        return withTrace("updateIssuer", options, async (updatedOptions) => {
            const { accountId, password } = options;
            const generatedOptions = Object.assign(Object.assign({}, updatedOptions), { credentials: {
                    accountId,
                    password
                } });
            if (updatedOptions.organizationId ||
                (updatedOptions.administratorContacts && updatedOptions.administratorContacts.length)) {
                generatedOptions.organizationDetails = {
                    id: updatedOptions.organizationId,
                    adminDetails: updatedOptions.administratorContacts
                        ? updatedOptions.administratorContacts.map((x) => ({
                            emailAddress: x.email,
                            phone: x.phone,
                            firstName: x.firstName,
                            lastName: x.lastName
                        }))
                        : undefined
                };
            }
            if (updatedOptions.enabled) {
                generatedOptions.attributes = {
                    enabled: updatedOptions.enabled
                };
            }
            const result = await this.client.updateCertificateIssuer(this.vaultUrl, issuerName, generatedOptions);
            return toPublicIssuer(result._response.parsedBody);
        });
    }
    /**
     * The getIssuer operation returns the specified certificate issuer resources in the
     * specified key vault. This operation requires the certificates/manageissuers/getissuers
     * permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * const certificateIssuer = await client.getIssuer("IssuerName");
     * console.log(certificateIssuer);
     * ```
     * Gets he specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param options - The optional parameters
     */
    getIssuer(issuerName, options = {}) {
        return withTrace("getIssuer", options, async (updatedOptions) => {
            const result = await this.client.getCertificateIssuer(this.vaultUrl, issuerName, updatedOptions);
            return toPublicIssuer(result._response.parsedBody);
        });
    }
    /**
     * The deleteIssuer operation permanently removes the specified certificate issuer from
     * the vault. This operation requires the certificates/manageissuers/deleteissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Provider");
     * await client.deleteIssuer("IssuerName");
     * ```
     * Deletes the specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param options - The optional parameters
     */
    deleteIssuer(issuerName, options = {}) {
        return withTrace("deleteIssuer", options, async (updatedOptions) => {
            const result = await this.client.deleteCertificateIssuer(this.vaultUrl, issuerName, updatedOptions);
            return toPublicIssuer(result._response.parsedBody);
        });
    }
    /**
     * Creates a new certificate. If this is the first version, the certificate resource is created.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * **Note:** Sending `Self` as the `issuerName` of the certificate's policy will create a self-signed certificate.
     *
     * This operation requires the certificates/create permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const certificatePolicy = {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * };
     * const createPoller = await client.beginCreateCertificate("MyCertificate", certificatePolicy);
     *
     * // The pending certificate can be obtained by calling the following method:
     * const pendingCertificate = createPoller.getResult();
     *
     * // Serializing the poller
     * const serialized = createPoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginCreateCertificate("MyCertificate", certificatePolicy, { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const certificate = await createPoller.pollUntilDone();
     * console.log(certificate);
     * ```
     * Creates a certificate
     * @param certificateName - The name of the certificate
     * @param certificatePolicy - The certificate's policy
     * @param options - Optional parameters
     */
    async beginCreateCertificate(certificateName, policy, options = {}) {
        const poller = new CreateCertificatePoller({
            vaultUrl: this.vaultUrl,
            client: this.client,
            certificateName,
            certificatePolicy: policy,
            createCertificateOptions: options,
            operationOptions: options,
            intervalInMs: options.intervalInMs,
            resumeFrom: options.resumeFrom
        });
        // This will initialize the poller's operation (the creation of the secret).
        await poller.poll();
        return poller;
    }
    /**
     * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const poller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await poller.pollUntilDone();
     * const certificate = await client.getCertificate("MyCertificate");
     * console.log(certificate);
     * ```
     * Retrieves a certificate from the certificate's name (includes the certificate policy)
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getCertificate(certificateName, options = {}) {
        return withTrace("getCertificate", options, async (updatedOptions) => {
            const result = await this.client.getCertificate(this.vaultUrl, certificateName, "", updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * Gets information about a specific certificate on a specific version. It won't return the certificate's policy. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const poller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await poller.pollUntilDone();
     * const certificateWithPolicy = await client.getCertificate("MyCertificate");
     * const certificate = await client.getCertificateVersion("MyCertificate", certificateWithPolicy.properties.version!);
     * console.log(certificate);
     * ```
     * Retrieves a certificate from the certificate's name and a specified version
     * @param certificateName - The name of the certificate
     * @param version - The specific version of the certificate
     * @param options - The optional parameters
     */
    getCertificateVersion(certificateName, version, options = {}) {
        return withTrace("getCertificateVersion", options, async (updatedOptions) => {
            if (!version) {
                throw new Error("The 'version' cannot be empty.");
            }
            const result = await this.client.getCertificate(this.vaultUrl, certificateName, version, updatedOptions);
            return getCertificateFromCertificateBundle(result);
        });
    }
    /**
     * Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format.
     * If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates. This operation requires the certificates/import permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * // See: @azure/keyvault-secrets
     * const certificateSecret = await secretClient.getSecret("MyCertificate");
     * const base64EncodedCertificate = certificateSecret.value!;
     * let buffer: Uint8Array;
     *
     * if (isNode) {
     *   buffer = Buffer.from(base64EncodedCertificate, "base64");
     * } else {
     *   buffer = Uint8Array.from(atob(base64EncodedCertificate), (c) => c.charCodeAt(0));
     * }
     *
     * await client.importCertificate("MyCertificate", buffer);
     * ```
     * Imports a certificate from a certificate's secret value
     * @param certificateName - The name of the certificate
     * @param certificateBytes - The PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key
     * @param options - The optional parameters
     */
    importCertificate(certificateName, certificateBytes, options = {}) {
        return withTrace("importCertificate", options, async (updatedOptions) => {
            var _a;
            const base64EncodedCertificate = parseCertificateBytes(certificateBytes, (_a = updatedOptions.policy) === null || _a === void 0 ? void 0 : _a.contentType);
            const result = await this.client.importCertificate(this.vaultUrl, certificateName, base64EncodedCertificate, updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * The getCertificatePolicy operation returns the specified certificate policy resources in the specified key vault. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * const policy = await client.getCertificatePolicy("MyCertificate");
     * console.log(policy);
     * ```
     * Gets a certificate's policy
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getCertificatePolicy(certificateName, options = {}) {
        return withTrace("getCertificatePolicy", options, async (updatedOptions) => {
            const result = await this.client.getCertificatePolicy(this.vaultUrl, certificateName, updatedOptions);
            return toPublicPolicy(result._response.parsedBody);
        });
    }
    /**
     * Updates the certificate policy for the specified certificate. This operation requires the certificates/update permission.
     * Gets a certificate's policy
     * @param certificateName - The name of the certificate
     * @param policy - The certificate policy
     * @param options - The optional parameters
     */
    updateCertificatePolicy(certificateName, policy, options = {}) {
        return withTrace("updateCertificatePolicy", options, async (updatedOptions) => {
            const corePolicy = toCorePolicy(undefined, policy);
            const result = await this.client.updateCertificatePolicy(this.vaultUrl, certificateName, corePolicy, updatedOptions);
            return toPublicPolicy(result._response.parsedBody);
        });
    }
    /**
     * Applies the specified update on the given certificate; the only elements updated are the
     * certificate's attributes. This operation requires the certificates/update permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await client.updateCertificateProperties("MyCertificate", "", {
     *   tags: {
     *     customTag: "value"
     *   }
     * });
     * ```
     * Updates a certificate
     * @param certificateName - The name of the certificate
     * @param version - The version of the certificate to update
     * @param options - The options, including what to update
     */
    updateCertificateProperties(certificateName, version, options = {}) {
        return withTrace("updateCertificateProperties", options, async (updatedOptions) => {
            const result = await this.client.updateCertificate(this.vaultUrl, certificateName, version, Object.assign(Object.assign({}, updatedOptions), { certificateAttributes: toCoreAttributes(options) }));
            return getCertificateFromCertificateBundle(result._response.parsedBody);
        });
    }
    /**
     * Gets the creation operation associated with a specified certificate. This operation requires the certificates/get permission.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const createPoller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     *
     * const poller = await client.getCertificateOperation("MyCertificate");
     * const pendingCertificate = poller.getResult();
     *
     * const certificateOperation = poller.getOperationState().certificateOperation;
     * console.log(certificateOperation);
     * ```
     * Gets a certificate's poller operation
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    async getCertificateOperation(certificateName, options = {}) {
        const poller = new CertificateOperationPoller({
            certificateName,
            client: this.client,
            vaultUrl: this.vaultUrl,
            intervalInMs: options.intervalInMs,
            resumeFrom: options.resumeFrom,
            operationOptions: options
        });
        // This will initialize the poller's operation, which pre-populates some necessary properties.
        await poller.poll();
        return poller;
    }
    /**
     * Deletes the creation operation for a specified certificate that is in the process of being created.
     * The certificate is no longer created. This operation requires the certificates/update permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await client.deleteCertificateOperation("MyCertificate");
     * await client.getCertificateOperation("MyCertificate"); // Throws error: Pending certificate not found: "MyCertificate"
     * ```
     * Delete a certificate's operation
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    deleteCertificateOperation(certificateName, options = {}) {
        return withTrace("deleteCertificateOperation", options, async (updatedOptions) => {
            const result = await this.client.deleteCertificateOperation(this.vaultUrl, certificateName, updatedOptions);
            return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, result._response.parsedBody);
        });
    }
    /**
     * Performs the merging of a certificate or certificate chain with a key pair currently available in the service. This operation requires the certificates/create permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Unknown",
     *   subject: "cn=MyCert"
     * });
     * const poller = await client.getCertificateOperation("MyCertificate");
     * const { csr } = poller.getOperationState().certificateOperation!;
     * const base64Csr = Buffer.from(csr!).toString("base64");
     * const wrappedCsr = ["-----BEGIN CERTIFICATE REQUEST-----", base64Csr, "-----END CERTIFICATE REQUEST-----"].join("\n");
     *
     * const fs = require("fs");
     * fs.writeFileSync("test.csr", wrappedCsr);
     *
     * // Certificate available locally made using:
     * //   openssl genrsa -out ca.key 2048
     * //   openssl req -new -x509 -key ca.key -out ca.crt
     * // You can read more about how to create a fake certificate authority here: https://gist.github.com/Soarez/9688998
     *
     * const childProcess = require("child_process");
     * childProcess.execSync("openssl x509 -req -in test.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out test.crt");
     * const base64Crt = fs.readFileSync("test.crt").toString().split("\n").slice(1, -1).join("");
     *
     * await client.mergeCertificate("MyCertificate", [Buffer.from(base64Crt)]);
     * ```
     * Merges a signed certificate request into a pending certificate
     * @param certificateName - The name of the certificate
     * @param x509Certificates - The certificate(s) to merge
     * @param options - The optional parameters
     */
    mergeCertificate(certificateName, x509Certificates, options = {}) {
        return withTrace("mergeCertificate", options, async (updatedOptions) => {
            const result = await this.client.mergeCertificate(this.vaultUrl, certificateName, x509Certificates, updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result._response.parsedBody);
        });
    }
    /**
     * Requests that a backup of the specified certificate be downloaded to the client. All versions of the certificate will be downloaded.
     * This operation requires the certificates/backup permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * const backup = await client.backupCertificate("MyCertificate");
     * ```
     * Generates a backup of a certificate
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    backupCertificate(certificateName, options = {}) {
        return withTrace("backupCertificate", options, async (updatedOptions) => {
            const result = await this.client.backupCertificate(this.vaultUrl, certificateName, updatedOptions);
            return result._response.parsedBody.value;
        });
    }
    /**
     * Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * const backup = await client.backupCertificate("MyCertificate");
     * const poller = await client.beginDeleteCertificate("MyCertificate");
     * await poller.pollUntilDone();
     * // Some time is required before we're able to restore the certificate
     * await client.restoreCertificateBackup(backup!);
     * ```
     * Restores a certificate from a backup
     * @param backup - The back-up certificate to restore from
     * @param options - The optional parameters
     */
    restoreCertificateBackup(backup, options = {}) {
        return withTrace("restoreCertificateBackup", options, async (updatedOptions) => {
            const result = await this.client.restoreCertificate(this.vaultUrl, backup, updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result._response.parsedBody);
        });
    }
    listDeletedCertificatesPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listDeletedCertificatesPage_1() {
            if (continuationState.continuationToken == null) {
                const requestOptionsComplete = Object.assign({ maxresults: continuationState.maxPageSize, includePending: options.includePending }, options);
                const currentSetResponse = yield __await(withTrace("listDeletedCertificates", requestOptionsComplete, (updatedOptions) => this.client.getDeletedCertificates(this.vaultUrl, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(getDeletedCertificateFromItem, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(withTrace("listDeletedCertificates", options, (updatedOptions) => this.client.getDeletedCertificates(continuationState.continuationToken, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(getDeletedCertificateFromItem, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listDeletedCertificatesAll(options = {}) {
        return __asyncGenerator(this, arguments, function* listDeletedCertificatesAll_1() {
            var e_4, _a;
            const f = {};
            try {
                for (var _b = __asyncValues(this.listDeletedCertificatesPage(f, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield __await(item);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Retrieves the certificates in the current vault which are in a deleted state and ready for recovery or purging. This operation includes deletion-specific
     * information. This operation requires the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * for await (const deletedCertificate of client.listDeletedCertificates()) {
     *   console.log(deletedCertificate);
     * }
     * for await (const page of client.listDeletedCertificates().byPage()) {
     *   for (const deletedCertificate of page) {
     *     console.log(deletedCertificate);
     *   }
     * }
     * ```
     * Lists deleted certificates
     * @param options - The optional parameters
     */
    listDeletedCertificates(options = {}) {
        const iter = this.listDeletedCertificatesAll(options);
        const result = {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listDeletedCertificatesPage(settings, options)
        };
        return result;
    }
    /**
     * retrieves the deleted certificate information plus its attributes, such as retention interval, scheduled permanent deletion and the
     * current deletion recovery level. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const deletedCertificate = await client.getDeletedCertificate("MyDeletedCertificate");
     * console.log("Deleted certificate:", deletedCertificate);
     * ```
     * Gets a deleted certificate
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getDeletedCertificate(certificateName, options = {}) {
        return withTrace("getDeletedCertificate", options, async (updatedOptions) => {
            const result = await this.client.getDeletedCertificate(this.vaultUrl, certificateName, updatedOptions);
            return getDeletedCertificateFromDeletedCertificateBundle(result._response.parsedBody);
        });
    }
    /**
     * Performs an irreversible deletion of the specified certificate, without possibility for recovery. The operation is not available if the
     * recovery level does not specify 'Purgeable'. This operation requires the certificate/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const deletePoller = await client.beginDeleteCertificate("MyCertificate");
     * await deletePoller.pollUntilDone();
     * // Deleting a certificate takes time, make sure to wait before purging it
     * client.purgeDeletedCertificate("MyCertificate");
     * ```
     * Gets a deleted certificate
     * @param certificateName - The name of the deleted certificate to purge
     * @param options - The optional parameters
     */
    async purgeDeletedCertificate(certificateName, options = {}) {
        return withTrace("purgeDeletedCertificate", options, async (updatedOptions) => {
            await this.client.purgeDeletedCertificate(this.vaultUrl, certificateName, updatedOptions);
            return null;
        });
    }
    /**
     * Recovers the deleted certificate in the specified vault. This operation can only be performed on a soft-delete enabled vault. This operation
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * This operation requires the certificates/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     *
     * const deletePoller = await client.beginDeleteCertificate("MyCertificate");
     * await deletePoller.pollUntilDone();
     *
     * const recoverPoller = await client.beginRecoverDeletedCertificate("MyCertificate");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginRecoverDeletedCertificate("MyCertificate", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const certificate = await recoverPoller.pollUntilDone();
     * console.log(certificate);
     * ```
     * Recovers a deleted certificate
     * @param certificateName - The name of the deleted certificate
     * @param options - The optional parameters
     */
    async beginRecoverDeletedCertificate(certificateName, options = {}) {
        const poller = new RecoverDeletedCertificatePoller(Object.assign(Object.assign({ certificateName, client: this.client, vaultUrl: this.vaultUrl }, options), { operationOptions: options }));
        // This will initialize the poller's operation (the recovery of the deleted secret).
        await poller.poll();
        return poller;
    }
}
//# sourceMappingURL=index.js.map